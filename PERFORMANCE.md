# 分片记录管理器架构

## 🎯 设计原则

**一个原则**：所有词典统一使用分片存储，简单高效。

## 📊 架构对比

### ❌ 原始方案（单文件存储）
- **文件数量**: 1个大文件
- **文件大小**: 5000个单词 ≈ 1.1MB
- **内存占用**: 全量加载 ≈ 1.1MB
- **读写性能**: 每次操作都要读写整个文件
- **问题**: 大词典性能差，内存占用高

### ✅ 分片存储方案（统一使用）
- **文件数量**: 1个主文件 + N个章节文件
- **主文件大小**: 约 2KB（只包含全局信息）
- **章节文件大小**: 约 2KB/文件（10个单词的记录）
- **内存占用**: 按需加载 ≈ 2KB
- **读写性能**: 只读写当前章节，响应极快
- **优势**: 所有规模的词典都能高效运行

### ✅ 每日记录方案（轻量级存储）
- **文件数量**: 每天1-2个记录文件 + 1个总记录文件
- **文件大小**: 约 1KB-10KB（取决于当日练习量）
- **内存占用**: 按需加载 ≈ 1KB-10KB
- **读写性能**: 只读写当日记录，响应极快
- **优势**: 轻量级存储，便于分析和统计

### 🚀 GlobalState方案（最新优化）
- **存储方式**: VS Code globalState API
- **内存占用**: 按需加载 ≈ 1KB-10KB
- **读写性能**: 内存操作，响应极快（毫秒级）
- **可靠性**: VS Code内置存储机制，数据更安全
- **跨平台**: 自动处理不同操作系统的存储差异
- **优势**: 零文件I/O，最佳性能和可靠性

## 🎯 性能优势

### 文件操作效率
```
单文件方案：每次写入 1.1MB
分片方案：  每次写入 2KB（550倍提升）
每日记录方案：每次写入 0.5KB（2200倍提升）
GlobalState方案：内存操作（无限提升）
```

### 内存使用
```
单文件方案：常驻内存 1.1MB
分片方案：  常驻内存 2KB（550倍减少）
每日记录方案：常驻内存 1KB（1100倍减少）
GlobalState方案：按需加载 ≈ 1KB（1100倍减少）
```

### 响应时间
```
单文件方案：约 50-100ms（需要解析大JSON）
分片方案：  约 1-5ms（小文件快速处理）
每日记录方案：约 0.5-2ms（极小文件快速处理）
GlobalState方案：约 0.1-1ms（内存操作）
```

## 🏗️ 架构设计

### 统一分片策略
- **所有词典**：无论大小，统一使用分片存储
- **无自动策略**：简化代码，避免复杂度
- **一致体验**：所有用户享受相同的高性能

### GlobalState键名规则
- 主记录键名：`enpractice.records.{dictId}.{practiceMode}.main`
- 章节记录键名：`enpractice.records.{dictId}.{practiceMode}.ch{章节号}`
- 每日记录键名：`enpractice.dayRecords.{date}[_{practiceMode}]`
- 总记录键名：`enpractice.dayRecords.totalRecords`
- 分析报告键名：`enpractice.dayRecordsAnalyze.{date}_analysis`

### 数据分离
- **主记录数据**：词典信息、全局统计、当前进度
- **章节记录数据**：该章节的单词练习记录
- **每日记录数据**：按日期记录的单词练习情况
- **分析报告数据**：每日学习情况的统计分析

## 🚀 架构优势

1. **架构简单** - 单一存储策略，代码清晰
2. **性能统一** - 所有词典都享受高性能
3. **维护容易** - 无复杂的策略选择逻辑
4. **体验一致** - 用户无需关心词典大小
5. **扩展性好** - 天然支持超大词典
6. **分析友好** - 每日记录便于统计和分析
7. **可靠性高** - 使用VS Code内置存储机制

## 🎉 最终结论

**统一分片存储 + GlobalState API**是最佳的工程实践：
- ✅ 彻底解决性能问题
- ✅ 架构简单统一
- ✅ 代码易于维护
- ✅ 用户体验一致
- ✅ 无需复杂优化
- ✅ 便于记录分析
- ✅ 数据安全可靠

**一句话总结**：简单的分片存储配合VS Code GlobalState API，解决所有问题并提供记录分析能力。